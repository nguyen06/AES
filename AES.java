
import java.io.*;


public class AES
{	
	private static String m;
	private static FileInputStream keyFile;
	private static FileInputStream inputFile;

	private final int Nb = 4;
	private int Nk = 8;
	private int Nr = 14; // number of round

	private byte[][] state;
	private static byte[] key;
	private static byte[] input;
	private int[] schedule;

	//constructor

	
	public static final int[] mul2 =
	{
		0x00,0x02,0x04,0x06,0x08,0x0a,0x0c,0x0e,0x10,0x12,0x14,0x16,0x18,0x1a,0x1c,0x1e,
		0x20,0x22,0x24,0x26,0x28,0x2a,0x2c,0x2e,0x30,0x32,0x34,0x36,0x38,0x3a,0x3c,0x3e,
		0x40,0x42,0x44,0x46,0x48,0x4a,0x4c,0x4e,0x50,0x52,0x54,0x56,0x58,0x5a,0x5c,0x5e,
		0x60,0x62,0x64,0x66,0x68,0x6a,0x6c,0x6e,0x70,0x72,0x74,0x76,0x78,0x7a,0x7c,0x7e,
		0x80,0x82,0x84,0x86,0x88,0x8a,0x8c,0x8e,0x90,0x92,0x94,0x96,0x98,0x9a,0x9c,0x9e,
		0xa0,0xa2,0xa4,0xa6,0xa8,0xaa,0xac,0xae,0xb0,0xb2,0xb4,0xb6,0xb8,0xba,0xbc,0xbe,
		0xc0,0xc2,0xc4,0xc6,0xc8,0xca,0xcc,0xce,0xd0,0xd2,0xd4,0xd6,0xd8,0xda,0xdc,0xde,
		0xe0,0xe2,0xe4,0xe6,0xe8,0xea,0xec,0xee,0xf0,0xf2,0xf4,0xf6,0xf8,0xfa,0xfc,0xfe,
		0x1b,0x19,0x1f,0x1d,0x13,0x11,0x17,0x15,0x0b,0x09,0x0f,0x0d,0x03,0x01,0x07,0x05,
		0x3b,0x39,0x3f,0x3d,0x33,0x31,0x37,0x35,0x2b,0x29,0x2f,0x2d,0x23,0x21,0x27,0x25,
		0x5b,0x59,0x5f,0x5d,0x53,0x51,0x57,0x55,0x4b,0x49,0x4f,0x4d,0x43,0x41,0x47,0x45,
		0x7b,0x79,0x7f,0x7d,0x73,0x71,0x77,0x75,0x6b,0x69,0x6f,0x6d,0x63,0x61,0x67,0x65,
		0x9b,0x99,0x9f,0x9d,0x93,0x91,0x97,0x95,0x8b,0x89,0x8f,0x8d,0x83,0x81,0x87,0x85,
		0xbb,0xb9,0xbf,0xbd,0xb3,0xb1,0xb7,0xb5,0xab,0xa9,0xaf,0xad,0xa3,0xa1,0xa7,0xa5,
		0xdb,0xd9,0xdf,0xdd,0xd3,0xd1,0xd7,0xd5,0xcb,0xc9,0xcf,0xcd,0xc3,0xc1,0xc7,0xc5,
		0xfb,0xf9,0xff,0xfd,0xf3,0xf1,0xf7,0xf5,0xeb,0xe9,0xef,0xed,0xe3,0xe1,0xe7,0xe5
	};

	public static final int[] mul3 = 
	{
		0x00,0x03,0x06,0x05,0x0c,0x0f,0x0a,0x09,0x18,0x1b,0x1e,0x1d,0x14,0x17,0x12,0x11,
		0x30,0x33,0x36,0x35,0x3c,0x3f,0x3a,0x39,0x28,0x2b,0x2e,0x2d,0x24,0x27,0x22,0x21,
		0x60,0x63,0x66,0x65,0x6c,0x6f,0x6a,0x69,0x78,0x7b,0x7e,0x7d,0x74,0x77,0x72,0x71,
		0x50,0x53,0x56,0x55,0x5c,0x5f,0x5a,0x59,0x48,0x4b,0x4e,0x4d,0x44,0x47,0x42,0x41,
		0xc0,0xc3,0xc6,0xc5,0xcc,0xcf,0xca,0xc9,0xd8,0xdb,0xde,0xdd,0xd4,0xd7,0xd2,0xd1,
		0xf0,0xf3,0xf6,0xf5,0xfc,0xff,0xfa,0xf9,0xe8,0xeb,0xee,0xed,0xe4,0xe7,0xe2,0xe1,
		0xa0,0xa3,0xa6,0xa5,0xac,0xaf,0xaa,0xa9,0xb8,0xbb,0xbe,0xbd,0xb4,0xb7,0xb2,0xb1,
		0x90,0x93,0x96,0x95,0x9c,0x9f,0x9a,0x99,0x88,0x8b,0x8e,0x8d,0x84,0x87,0x82,0x81,
		0x9b,0x98,0x9d,0x9e,0x97,0x94,0x91,0x92,0x83,0x80,0x85,0x86,0x8f,0x8c,0x89,0x8a,
		0xab,0xa8,0xad,0xae,0xa7,0xa4,0xa1,0xa2,0xb3,0xb0,0xb5,0xb6,0xbf,0xbc,0xb9,0xba,
		0xfb,0xf8,0xfd,0xfe,0xf7,0xf4,0xf1,0xf2,0xe3,0xe0,0xe5,0xe6,0xef,0xec,0xe9,0xea,
		0xcb,0xc8,0xcd,0xce,0xc7,0xc4,0xc1,0xc2,0xd3,0xd0,0xd5,0xd6,0xdf,0xdc,0xd9,0xda,
		0x5b,0x58,0x5d,0x5e,0x57,0x54,0x51,0x52,0x43,0x40,0x45,0x46,0x4f,0x4c,0x49,0x4a,
		0x6b,0x68,0x6d,0x6e,0x67,0x64,0x61,0x62,0x73,0x70,0x75,0x76,0x7f,0x7c,0x79,0x7a,
		0x3b,0x38,0x3d,0x3e,0x37,0x34,0x31,0x32,0x23,0x20,0x25,0x26,0x2f,0x2c,0x29,0x2a,
		0x0b,0x08,0x0d,0x0e,0x07,0x04,0x01,0x02,0x13,0x10,0x15,0x16,0x1f,0x1c,0x19,0x1a
	};

	public static final int[] mul9 =
	{
		0x00,0x09,0x12,0x1b,0x24,0x2d,0x36,0x3f,0x48,0x41,0x5a,0x53,0x6c,0x65,0x7e,0x77,
		0x90,0x99,0x82,0x8b,0xb4,0xbd,0xa6,0xaf,0xd8,0xd1,0xca,0xc3,0xfc,0xf5,0xee,0xe7,
		0x3b,0x32,0x29,0x20,0x1f,0x16,0x0d,0x04,0x73,0x7a,0x61,0x68,0x57,0x5e,0x45,0x4c,
		0xab,0xa2,0xb9,0xb0,0x8f,0x86,0x9d,0x94,0xe3,0xea,0xf1,0xf8,0xc7,0xce,0xd5,0xdc,
		0x76,0x7f,0x64,0x6d,0x52,0x5b,0x40,0x49,0x3e,0x37,0x2c,0x25,0x1a,0x13,0x08,0x01,
		0xe6,0xef,0xf4,0xfd,0xc2,0xcb,0xd0,0xd9,0xae,0xa7,0xbc,0xb5,0x8a,0x83,0x98,0x91,
		0x4d,0x44,0x5f,0x56,0x69,0x60,0x7b,0x72,0x05,0x0c,0x17,0x1e,0x21,0x28,0x33,0x3a,
		0xdd,0xd4,0xcf,0xc6,0xf9,0xf0,0xeb,0xe2,0x95,0x9c,0x87,0x8e,0xb1,0xb8,0xa3,0xaa,
		0xec,0xe5,0xfe,0xf7,0xc8,0xc1,0xda,0xd3,0xa4,0xad,0xb6,0xbf,0x80,0x89,0x92,0x9b,
		0x7c,0x75,0x6e,0x67,0x58,0x51,0x4a,0x43,0x34,0x3d,0x26,0x2f,0x10,0x19,0x02,0x0b,
		0xd7,0xde,0xc5,0xcc,0xf3,0xfa,0xe1,0xe8,0x9f,0x96,0x8d,0x84,0xbb,0xb2,0xa9,0xa0,
		0x47,0x4e,0x55,0x5c,0x63,0x6a,0x71,0x78,0x0f,0x06,0x1d,0x14,0x2b,0x22,0x39,0x30,
		0x9a,0x93,0x88,0x81,0xbe,0xb7,0xac,0xa5,0xd2,0xdb,0xc0,0xc9,0xf6,0xff,0xe4,0xed,
		0x0a,0x03,0x18,0x11,0x2e,0x27,0x3c,0x35,0x42,0x4b,0x50,0x59,0x66,0x6f,0x74,0x7d,
		0xa1,0xa8,0xb3,0xba,0x85,0x8c,0x97,0x9e,0xe9,0xe0,0xfb,0xf2,0xcd,0xc4,0xdf,0xd6,
		0x31,0x38,0x23,0x2a,0x15,0x1c,0x07,0x0e,0x79,0x70,0x6b,0x62,0x5d,0x54,0x4f,0x46
	};

	public static final int[] mul11 =
	{
		0x00,0x0b,0x16,0x1d,0x2c,0x27,0x3a,0x31,0x58,0x53,0x4e,0x45,0x74,0x7f,0x62,0x69,
		0xb0,0xbb,0xa6,0xad,0x9c,0x97,0x8a,0x81,0xe8,0xe3,0xfe,0xf5,0xc4,0xcf,0xd2,0xd9,
		0x7b,0x70,0x6d,0x66,0x57,0x5c,0x41,0x4a,0x23,0x28,0x35,0x3e,0x0f,0x04,0x19,0x12,
		0xcb,0xc0,0xdd,0xd6,0xe7,0xec,0xf1,0xfa,0x93,0x98,0x85,0x8e,0xbf,0xb4,0xa9,0xa2,
		0xf6,0xfd,0xe0,0xeb,0xda,0xd1,0xcc,0xc7,0xae,0xa5,0xb8,0xb3,0x82,0x89,0x94,0x9f,
		0x46,0x4d,0x50,0x5b,0x6a,0x61,0x7c,0x77,0x1e,0x15,0x08,0x03,0x32,0x39,0x24,0x2f,
		0x8d,0x86,0x9b,0x90,0xa1,0xaa,0xb7,0xbc,0xd5,0xde,0xc3,0xc8,0xf9,0xf2,0xef,0xe4,
		0x3d,0x36,0x2b,0x20,0x11,0x1a,0x07,0x0c,0x65,0x6e,0x73,0x78,0x49,0x42,0x5f,0x54,
		0xf7,0xfc,0xe1,0xea,0xdb,0xd0,0xcd,0xc6,0xaf,0xa4,0xb9,0xb2,0x83,0x88,0x95,0x9e,
		0x47,0x4c,0x51,0x5a,0x6b,0x60,0x7d,0x76,0x1f,0x14,0x09,0x02,0x33,0x38,0x25,0x2e,
		0x8c,0x87,0x9a,0x91,0xa0,0xab,0xb6,0xbd,0xd4,0xdf,0xc2,0xc9,0xf8,0xf3,0xee,0xe5,
		0x3c,0x37,0x2a,0x21,0x10,0x1b,0x06,0x0d,0x64,0x6f,0x72,0x79,0x48,0x43,0x5e,0x55,
		0x01,0x0a,0x17,0x1c,0x2d,0x26,0x3b,0x30,0x59,0x52,0x4f,0x44,0x75,0x7e,0x63,0x68,
		0xb1,0xba,0xa7,0xac,0x9d,0x96,0x8b,0x80,0xe9,0xe2,0xff,0xf4,0xc5,0xce,0xd3,0xd8,
		0x7a,0x71,0x6c,0x67,0x56,0x5d,0x40,0x4b,0x22,0x29,0x34,0x3f,0x0e,0x05,0x18,0x13,
		0xca,0xc1,0xdc,0xd7,0xe6,0xed,0xf0,0xfb,0x92,0x99,0x84,0x8f,0xbe,0xb5,0xa8,0xa3
	};
	public static final int[] mul13 =
	{
		0x00,0x0d,0x1a,0x17,0x34,0x39,0x2e,0x23,0x68,0x65,0x72,0x7f,0x5c,0x51,0x46,0x4b,
		0xd0,0xdd,0xca,0xc7,0xe4,0xe9,0xfe,0xf3,0xb8,0xb5,0xa2,0xaf,0x8c,0x81,0x96,0x9b,
		0xbb,0xb6,0xa1,0xac,0x8f,0x82,0x95,0x98,0xd3,0xde,0xc9,0xc4,0xe7,0xea,0xfd,0xf0,
		0x6b,0x66,0x71,0x7c,0x5f,0x52,0x45,0x48,0x03,0x0e,0x19,0x14,0x37,0x3a,0x2d,0x20,
		0x6d,0x60,0x77,0x7a,0x59,0x54,0x43,0x4e,0x05,0x08,0x1f,0x12,0x31,0x3c,0x2b,0x26,
		0xbd,0xb0,0xa7,0xaa,0x89,0x84,0x93,0x9e,0xd5,0xd8,0xcf,0xc2,0xe1,0xec,0xfb,0xf6,
		0xd6,0xdb,0xcc,0xc1,0xe2,0xef,0xf8,0xf5,0xbe,0xb3,0xa4,0xa9,0x8a,0x87,0x90,0x9d,
		0x06,0x0b,0x1c,0x11,0x32,0x3f,0x28,0x25,0x6e,0x63,0x74,0x79,0x5a,0x57,0x40,0x4d,
		0xda,0xd7,0xc0,0xcd,0xee,0xe3,0xf4,0xf9,0xb2,0xbf,0xa8,0xa5,0x86,0x8b,0x9c,0x91,
		0x0a,0x07,0x10,0x1d,0x3e,0x33,0x24,0x29,0x62,0x6f,0x78,0x75,0x56,0x5b,0x4c,0x41,
		0x61,0x6c,0x7b,0x76,0x55,0x58,0x4f,0x42,0x09,0x04,0x13,0x1e,0x3d,0x30,0x27,0x2a,
		0xb1,0xbc,0xab,0xa6,0x85,0x88,0x9f,0x92,0xd9,0xd4,0xc3,0xce,0xed,0xe0,0xf7,0xfa,
		0xb7,0xba,0xad,0xa0,0x83,0x8e,0x99,0x94,0xdf,0xd2,0xc5,0xc8,0xeb,0xe6,0xf1,0xfc,
		0x67,0x6a,0x7d,0x70,0x53,0x5e,0x49,0x44,0x0f,0x02,0x15,0x18,0x3b,0x36,0x21,0x2c,
		0x0c,0x01,0x16,0x1b,0x38,0x35,0x22,0x2f,0x64,0x69,0x7e,0x73,0x50,0x5d,0x4a,0x47,
		0xdc,0xd1,0xc6,0xcb,0xe8,0xe5,0xf2,0xff,0xb4,0xb9,0xae,0xa3,0x80,0x8d,0x9a,0x97
	};

	public static final int[] mul14 =
	{
		0x00,0x0e,0x1c,0x12,0x38,0x36,0x24,0x2a,0x70,0x7e,0x6c,0x62,0x48,0x46,0x54,0x5a,
		0xe0,0xee,0xfc,0xf2,0xd8,0xd6,0xc4,0xca,0x90,0x9e,0x8c,0x82,0xa8,0xa6,0xb4,0xba,
		0xdb,0xd5,0xc7,0xc9,0xe3,0xed,0xff,0xf1,0xab,0xa5,0xb7,0xb9,0x93,0x9d,0x8f,0x81,
		0x3b,0x35,0x27,0x29,0x03,0x0d,0x1f,0x11,0x4b,0x45,0x57,0x59,0x73,0x7d,0x6f,0x61,
		0xad,0xa3,0xb1,0xbf,0x95,0x9b,0x89,0x87,0xdd,0xd3,0xc1,0xcf,0xe5,0xeb,0xf9,0xf7,
		0x4d,0x43,0x51,0x5f,0x75,0x7b,0x69,0x67,0x3d,0x33,0x21,0x2f,0x05,0x0b,0x19,0x17,
		0x76,0x78,0x6a,0x64,0x4e,0x40,0x52,0x5c,0x06,0x08,0x1a,0x14,0x3e,0x30,0x22,0x2c,
		0x96,0x98,0x8a,0x84,0xae,0xa0,0xb2,0xbc,0xe6,0xe8,0xfa,0xf4,0xde,0xd0,0xc2,0xcc,
		0x41,0x4f,0x5d,0x53,0x79,0x77,0x65,0x6b,0x31,0x3f,0x2d,0x23,0x09,0x07,0x15,0x1b,
		0xa1,0xaf,0xbd,0xb3,0x99,0x97,0x85,0x8b,0xd1,0xdf,0xcd,0xc3,0xe9,0xe7,0xf5,0xfb,
		0x9a,0x94,0x86,0x88,0xa2,0xac,0xbe,0xb0,0xea,0xe4,0xf6,0xf8,0xd2,0xdc,0xce,0xc0,
		0x7a,0x74,0x66,0x68,0x42,0x4c,0x5e,0x50,0x0a,0x04,0x16,0x18,0x32,0x3c,0x2e,0x20,
		0xec,0xe2,0xf0,0xfe,0xd4,0xda,0xc8,0xc6,0x9c,0x92,0x80,0x8e,0xa4,0xaa,0xb8,0xb6,
		0x0c,0x02,0x10,0x1e,0x34,0x3a,0x28,0x26,0x7c,0x72,0x60,0x6e,0x44,0x4a,0x58,0x56,
		0x37,0x39,0x2b,0x25,0x0f,0x01,0x13,0x1d,0x47,0x49,0x5b,0x55,0x7f,0x71,0x63,0x6d,
		0xd7,0xd9,0xcb,0xc5,0xef,0xe1,0xf3,0xfd,0xa7,0xa9,0xbb,0xb5,0x9f,0x91,0x83,0x8d
	};
	public static final int[] rcon = 
	{
		0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 
	    0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 
	    0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 
	    0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 
	    0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 
	    0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 
	    0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 
	    0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 
	    0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 
	    0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 
	    0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 
	    0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 0x61, 0xc2, 0x9f, 
	    0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d, 0x01, 0x02, 0x04, 
	    0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 
	    0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91, 0x39, 0x72, 0xe4, 0xd3, 0xbd, 
	    0x61, 0xc2, 0x9f, 0x25, 0x4a, 0x94, 0x33, 0x66, 0xcc, 0x83, 0x1d, 0x3a, 0x74, 0xe8, 0xcb, 0x8d
		
	};

	// construction 
	public AES(byte[] key)
	{
		// check the bits of key
		int bit = key.length *8;
		System.out.println("the bit is " + bit);
		if(bit!= 128 && bit != 192 && bit != 256){
			throw new RuntimeException("Invalue AES key size (" + bit + "bits)");
		}
		schedule = new int[Nb * (Nr +1)];
		KeyExpansion();
	}
	/*
	 Procedure Name
	   KeyExpansion(K,k[])

	Input:
	   K: 256 bits cipher key
	   Rcon[]: Round constant array
	   SubWord(): Word substitution procedure
	   RotWord(): Word rotation procedure

	Output:
	   k[14]: 14 round keys as 4x4 byte arrays

	Algorithm:
	   w[4*14]              # a word array holding 14 round keys
	   w[0..3] = K          # setting cipher key as the first round key
	   
	   for i = 4 to 43      # computing words of other round keys
	      temp = w[i-1]     # copying previous word to a temp variable
	      if (i mod 8 = 0)
	         temp = SubWord(RotWord(temp)) 
	         temp = temp XOR Rcon[i/4]
	      end if
	      w[i] = w[i-4] XOR temp
	   end for
	    
	   for i = 0 to 10      # building 11 round keys as 4x4 byte arrays
	      k[i] = w[4*i..4*i+3]
	   end for
	 */
	private void KeyExpansion()
	{
		int temp;
		for (int i = 8; i < 60 ; i++)
		{
			temp = schedule[i-1];
			if(i % 8 == 0)
			{
				temp = SubWork(RotWord(temp));
				temp ^= rcon[i/8];
			}else if(Nk > 8 && i % Nk == 4)
			{
				temp = SubWork(temp);
			}
			schedule[i] = schedule[i-Nk] ^ temp;
		}
	}
	/**
	 * 
	 */
	private byte[][] subkey(byte[][] key, int start)
	{
		byte[][] skey = new byte[4][4];
		for(int i = 0 ; i < 4; i ++)
		{
			for(int j = 0; j < 4; j++)
			{
				skey[i][j] = key[i][4 * start + j];
			}
		}
		return skey;
	}

	private int RotWord(int i)
	{
		return Integer.rotateLeft(i, 8);
	}

	private int SubWork(int i)
	{
		return ((sBox.substitution((i >>> 24))) << 24) |
                ((sBox.substitution((i >>> 16) & 0xff) & 0xff) << 16) |
                ((sBox.substitution((i >>> 8) & 0xff) & 0xff) << 8) |
                ((sBox.substitution((i) & 0xff) & 0xff));
	}

	/*
     * In the AddRoundKey step, the subkey is combined with the state
     * For each round, a subkey is derived from the main key using
     * Rijindael's key schedule; each subkey is the same size as the
     * state. The subkey is added by combining each byte of the state
     * with the corresponding byte of the subkey using bitwise XOR
     * 
     * input: state , key 
	 */
	public void AddRoundKey(int round) 
	{

		for(int i = 0 ; i < Nb ; i++)
		{
			//System.out.println("round number "  + round + "i " + i);
			//System.out.println("schedule length " + schedule.length);
			int temp = schedule[round * 4 + i];
			state[0][i] ^= (temp >>> 24) & 0xff;
			state[1][i] ^= (temp >>> 16) & 0xff;
			state[2][i] ^= (temp >>> 8) & 0xff;
			state[3][i] ^= (temp) & 0xff;
		}
	}

	
	/*
	 *Replace all elements in the passed array with value in sbox[][]
	 *
	 * input: state 
	 * return the array who's value was replaced
	 */
	public void SubBytes() 
	{
		for(int i = 0 ; i < 4; i++)
		{
			for(int j = 0 ; j < 4; j++){
				//int hexadecimal = state[j][i];
				state[j][i] = sBox.substitution(state[j][i]);
			}
		}
	}

	public void InvSubBytes() 
	{
		for(int i = 0 ; i < 4; i++)
		{
			for(int j = 0 ; j < 4; j++){
				//int hexadecimal = state[j][i];
				state[j][i] = sBox.inv_substitution(state[j][i]);
			}
		}
	}
	/**
	 * left shift each row of the matrix 
	 *
	 * left shift the nth row with n-1 times
	 * input : state
	 * 
	 * Java.lang.System.arraycopy() methd copies an array from the 
	 * specified source array, beginning at the specified position, 
	 * to the specified of distination array
	 * public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)
	 */
	public void ShiftRows() 
	{
		byte temp;
		for(int i = 0; i < 4; i++)
		{
			for(int k = 0 ; k < i ; k++)
			{
				temp = state[i][0];
				System.arraycopy(state[i], 1, state[i], 0, 3);
				state[i][3] = temp;
			}
		}
	}

	public void InvShiftRows() 
	{
		byte temp;
		for(int i = 0; i < 4; i++)
		{
			for(int k = 0 ; k < i ; k++)
			{
				temp = state[i][0];
				System.arraycopy(state[i], 0, state[i], 1, 3);
				state[i][0] = temp;
			}
		}
	}

	// /**
	//  * the size of the state is assumed to be 4, 
	//  */
	// private int[] shiftLeft(int[] state, int times_shift)
	// {
	// 	if(times_shift % 4 == 0)
	// 	{
	// 		return state;
	// 	}
	// 	while(times_shift > 0)
	// 	{
	// 		int temp = state[0];
	// 		for(int i = 0 ; i < state.length -1 ; i++)
	// 		{
	// 			state[i]= state[i+1];
	// 		}
	// 		state[state.length -1] = temp;
	// 		--times_shift;
	// 	}
	// 	return state;
	// }
	/*
	private void MixColumns() {
        byte[] temp;
        for (int j = 0; j < 4; j++) {
        	//System.out.println(state.length);
            temp = new byte[]{state[0][j], state[1][j], state[2][j], state[3][j]};
            for(int i = 0; i < temp.length ; i++)
            {
            	System.out.print(temp[i] + " ");
            }
            
            state[0][j] = (byte) (mul2[Math.abs(temp[0])] ^ mul3[Math.abs(temp[1])] ^ Math.abs(temp[2]) ^ Math.abs(temp[3]));
            state[1][j] = (byte) (Math.abs(temp[0]) ^ mul2[Math.abs(temp[1])] ^ mul3[Math.abs(temp[2])] ^ Math.abs(temp[3]));
            state[2][j] = (byte) (Math.abs(temp[0]) ^ Math.abs(temp[1]) ^ mul2[Math.abs(temp[2])] ^ mul3[Math.abs(temp[3])]);
            state[3][j] = (byte) (mul3[Math.abs(temp[0])] ^ Math.abs(temp[1]) ^ Math.abs(temp[2]) ^ mul2[Math.abs(temp[3])]);
        }
        
    }
	*/
    private void MixColumns() {
        byte[] temp;
        temp = new byte[]{state[0][j], state[1][j], state[2][j], state[3][j]};
            
        for (int j = 0; j < 4; j++) {
        	
        
    }
    /*
	public void InvMixColumns() 
	{
		byte[] temp;
		for (int j = 0; j < 4; j++) 
		{
            temp = new byte[]{state[0][j], state[1][j], state[2][j], state[3][j]};
            for(int i = 0; i < temp.length ; i++)
            {
            	System.out.print(temp[i] + " ");
            }
            state[0][j] = (byte) (mul14[Math.abs(temp[0])] ^ mul11[Math.abs(temp[1])] ^ mul13[Math.abs(temp[2])] ^ mul9[Math.abs(temp[3])]);
            state[1][j] = (byte) (mul9[Math.abs(temp[0])] ^ mul14[Math.abs(temp[1])] ^ mul11[Math.abs(temp[2])] ^ mul13[Math.abs(temp[3])]);
            state[2][j] = (byte) (mul13[Math.abs(temp[0])] ^ mul9[Math.abs(temp[1])] ^ mul14[Math.abs(temp[2])] ^ mul11[Math.abs(temp[3])]);
            state[3][j] = (byte) (mul11[Math.abs(temp[0])] ^ mul13[Math.abs(temp[1])] ^ mul9[Math.abs(temp[2])] ^ mul14[Math.abs(temp[3])]);
        }

	}
	*/
	public void InvMixColumns() 
	{
		byte[] temp;
		for (int j = 0; j < 4; j++) 
		{
            temp = new byte[]{state[0][j], state[1][j], state[2][j], state[3][j]};
            for(int i = 0; i < temp.length ; i++)
            {
            	System.out.print(128+temp[i] + " ");
            }
            state[0][j] = (byte) (mul14[128 + temp[0]] ^ mul11[128 +temp[1]] ^ mul13[128+temp[2]] ^ mul9[128+temp[3]]);
            state[1][j] = (byte) (mul9[128+temp[0]] ^ mul14[128+temp[1]] ^ mul11[128+temp[2]] ^ mul13[128+temp[3]]);
            state[2][j] = (byte) (mul13[128+temp[0]] ^ mul9[128+temp[1]] ^ mul14[128+temp[2]] ^ mul11[128+temp[3]]);
            state[3][j] = (byte) (mul11[128+temp[0]] ^ mul13[128+temp[1]] ^ mul9[128+temp[2]] ^ mul14[128+temp[3]]);
        }

	}
	/*
	public void InvMixColumns() 
	{
		byte[] temp;
		for (int j = 0; j < 4; j++) 
		{
            temp = new byte[]{state[0][j], state[1][j], state[2][j], state[3][j]};
            state[0][j] = (byte) (mul14[temp[0]] ^ mul11[temp[1]] ^ mul13[temp[2]] ^ mul9[temp[3]]);
            state[1][j] = (byte) (mul9[temp[0]] ^ mul14[temp[1]] ^ mul11[temp[2]] ^ mul13[temp[3]]);
            state[2][j] = (byte) (mul13[temp[0]] ^ mul9[temp[1]] ^ mul14[temp[2]] ^ mul11[temp[3]]);
            state[3][j] = (byte) (mul11[temp[0]] ^ mul13[temp[1]] ^ mul9[temp[2]] ^ mul14[temp[3]]);
        }
	}
	*/
	private void encrypt(byte[] input)
	{
		this.state = new byte[4][4];

		for(int i = 0; i < 4; i++)
		{
			for(int j = 0; j < 4; j++)
			{
				//System.out.println("hahha" + input.length);
				this.state[j][i] = input[4 * i + j];
				//System.out.println("he");
		}
			}

		int numberOfRounds = 14;
		AddRoundKey(0);
		for(int round = 1 ; round < numberOfRounds ; round++)
		{
			SubBytes();
			ShiftRows();
			MixColumns();
			AddRoundKey(round);
		}
		
		SubBytes();
		MixColumns();
		AddRoundKey(Nr);

	}
	/*
	 * using the encrypt result to find the decrypt 
	 */
	private void decrypt(byte[] input)
	{
		this.state = new byte[4][4];
		for(int i = 0 ; i < 4 ; i++)
		{
			for(int j = 0 ; j < 4 ; j++)
			{
				this.state[j][i] = input[4 * i + j];
			}
		}
		AddRoundKey(Nr);
		for(int r = 1 ; r < Nr; r++)
		{
			InvShiftRows();
			InvSubBytes();
			AddRoundKey(Nr - r);
			InvMixColumns();
		}
		InvShiftRows();
		InvSubBytes();
		AddRoundKey(0);
	}

	/*
	 * this method convert from hexadecimal to byte
	 * this method is obtained from website https://github.com/VinayakShukl/AES-256/blob/master/src/utils.java
	 */
	public static byte[] hexToByte(String s)
	{
		int l = s.length();
		byte[] data = new byte[l/2];
		for(int i = 0; i < l ; i +=2)
		{
			data[i/2] = (byte)((Character.digit(s.charAt(i), 16) << 4) 
				+ Character.digit(s.charAt(i+1),16));
		}
		return data;
	}
	public static void main(String[] args) throws IOException
	{
		// read arguments from command line
		if(args.length < 3)
		{
			System.err.println("Not enough arguments to run!");
			System.exit(1);
		}else if(args[0].length() != 1)
		{
			System.err.println("wrong with e or d ");
			System.exit(1);
		}else if(args[0].charAt(0) != 'e' && args[0].charAt(0) != 'd')
		{
			System.err.println("Error with the e or d key ");
			System.exit(1);
		}

		m = args[0];

		try{

			keyFile = new FileInputStream(args[1]);
			inputFile = new FileInputStream(args[2]);

		}catch(FileNotFoundException e){
			System.err.println("File does not exit. Please check again. \n");
			System.exit(1);
		}
		System.out.println("the key file " + keyFile);
		// read key from the key file and transfer to byte
		int k;
		StringBuilder s1 = new StringBuilder();
		while((k = keyFile.read()) != -1)
		{
			//System.out.println((char)k);
			s1.append((char)k);
		}
		key = hexToByte(s1.toString());

		// for(int i = 0 ; i < key.length ; i++){
		// 	System.out.print(key[i] + " ");
		// }
		// read the input from the input file and trnasfer to by
		int w;
		StringBuilder s2 = new StringBuilder();
		while((w = inputFile.read()) != -1)
		{
			// ignore the new line and carriage return from the input file
			if((char) w == '\n' || (char)w == '\r')
			{
				continue;
			}
			//System.out.print((char)w + " ");
			s2.append((char)w);
		}
		input = hexToByte(s2.toString());

		// for(int i = 0 ; i < input.length ; i++){
		// 	System.out.print(input[i] + " ");
		// }
		//System.out.println(input);
		//create a constructor for AES
		AES test = new AES(key);

		File in = new File(args[2]);


		System.out.print("\nKey		:");
		// for (int i = 0; i < test.Nk * 4; i++)
  //           System.out.print(String.format("%02x", key[i]));

        if(m.charAt(0) == 'e')
        {
        	File newFile = new File(args[2] + ".enc");
        	in.renameTo(newFile);
        	FileWriter fw = new FileWriter(newFile);

        	System.out.println("input length "+ input.length);
        	test.encrypt(input);
        	System.out.print("\nCipher text:");

        	for (int i = 0; i < 4; i++) {
                for (int j = 0; j < 4; j++) {
                    System.out.print(String.format("%02x", test.state[j][i]));
                    fw.write(String.format("%02x", test.state[j][i]));
                }
            }
            System.out.println();
            System.out.println("\nCiphertext written to: " + newFile);
            fw.close();
        }
        else{
        	File newFile = new File(args[2] + ".dec");
        	in.renameTo(newFile);
        	FileWriter f = new FileWriter(newFile);
        	test.decrypt(input);

        	for (int i = 0; i < 4; i++) {
                for (int j = 0; j < 4; j++) {
                    System.out.print(String.format("%02x", test.state[j][i]));
                    f.write(String.format("%02x", test.state[j][i]));
                }
            }

            System.out.println();
            System.out.println("\nPlaintext written to: " + newFile);
            f.close();
        }
	}
}

